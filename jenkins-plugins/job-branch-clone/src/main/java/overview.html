<html xmlns:j="http://www.w3.org/1999/html">

<body>

<h2>Jenkins Plugins GUI Architecture</h2>
Usually when we write a plugin we actually just implement some interface that is an extension point.<br/>

Jenkins works by creating UI with jelly scripts, binding them to urls with stapler and executing methods from java.<br/>

The project structure convention is that if we have a class implementing an extension point called MyExtensionPoint.java
that resides in a package org.mine.plugin, e.g.
/src/main/java/org/mine/plugin/MyExtensionPoint.java
we should create a resource folder matching the canonical path of the class, e.g.
/src/main/resources/org/mine/plugin/MyExtensionPoint/
and in this folder put all of our jelly files.<br/>

This makes them available to misc existing jelly files. For example, implementing a BuildStep extension point and adding
a config.jelly file (in our example /src/main/resources/org/mine/plugin/MyExtensionPoint/config.jelly) will load the
content of that jelly file when someone clicks the "Add Build Step" in the job configuration page.
Adding a global.jelly file will add a section in the global jenkins configurations that corresponds that corresponds
to a static inner class that implements Descriptor (e.g. DescriptorImpl)<br/>

Some extension points bind urls to object instances.
For example, when we access the jenkins root url, e.g. http://localhost:8080/jenkins we arrive at the Jenkins singleton.
If we try to access a url such as http://localhost:8080/jenkins/someUrl the instance bound by
http://localhost:8080/jenkins will be searched for appropriate appendages, e.g. Jenkins.getInstance will look for
a method by the name of doSomeUrl, or corresponding jelly files someUrl.jelly, or a getDynamic function may be invoked
with the token "someUrl", or bind to the Object attainable from a getter gerSomeUrl() etc etc etc...
this logic can be seen in {@link org.kohsuke.stapler.MetaClass#buildDispatchers()} and
{@link org.kohsuke.stapler.Stapler#tryInvoke(RequestImpl, ResponseImpl, Object}.<br/>

when accessing a url root
(e.g. in our example if there was a method getSomeUrl() that returned an instance, what would we do with this instance?),
the default is to search for the token index, same as most servers that will redirect you to
index.html or index.php etc. so stapler will interpret this as an attempt to reach doIndex() or index.jelly or
getDynamic("index"). <br/>

another possibility is to see if the class is an @ExportedBean in which case it may just be serialized.

<h2>Jelly</h2>

jelly starts with xml namespace bindings. some of these map to java classes that are the jelly implementation.
you can notice this by the use of a colon (e.g. xmlns:j="jelly:core"), while including other jelly files is achieved by
regular folder inclusion (e.g. xmlns:l="/lib/layout" - an actual folder containing jelly files in the jenkins jars).

the xml elements are expanded dynamically during jelly execution.

the common available operations are categorized as follows:
jelly:core - control flow operations, such as for, if, set, invokeStatic etc...
lib/layout - jelly scripts that display the jenkins UI. use to make your UI look "jenkinsy".
lib/form - used to generate html form elements such as checkboxes, radiobuttons and textboxes.
jelly:staple - used to create stapler bindings between client and server via javascript "proxy" stubs.

to embed server code during jelly processing use ${ code comes here }.
to access the class that is the jelly context while jelly is processed on the servside, use ${it}.
for example, to print the type of the class that is the context you can ${it.getClass().getName()}

<p/>

and as they say in hebrew... &quot;&#1493;&#1488;&#1497;&#1491;&#1498; &#1494;&#1497;&#1500; &#1490;&#1502;&#1493;&#1512;&quot;

</body>
</html>